#!/usr/bin/env python3
"""
strelka-frontend

Command line utility for running Strelka frontend server components.
"""
import argparse
from concurrent import futures
import datetime
import hashlib
import json
import logging.config
import os
import math
import signal
import sys
import time
import uuid

from boltons import iterutils
import inflection
import grpc
import redis
import requests
import yaml

from strelka.proto import strelka_pb2
from strelka.proto import strelka_pb2_grpc


def remap_evt(result, case='camel'):
    def camel(path, key, value):
        if not isinstance(key, int):
            return (inflection.camelize(key, False), value)
        return (key, value)

    def pascal(path, key, value):
        if not isinstance(key, int):
            return (inflection.camelize(key, True), value)
        return (key, value)

    def snake(path, key, value):
        if not isinstance(key, int):
            return (inflection.underscore(key), value)
        return (key, value)

    remapped = iterutils.remap(
        result,
        lambda p, k, v: v != '' and v != [] and v != {} and v is not None,
    )

    if case == 'camel':
        return iterutils.remap(remapped, visit=camel)
    elif case == 'pascal':
        return iterutils.remap(remapped, visit=pascal)
    if case == 'snake':
        return iterutils.remap(remapped, visit=snake)
    else:
        return remapped


class StrelkaServicer(strelka_pb2_grpc.StrelkaServicer):
    def __init__(self, filekeeper, gatekeeper, jobkeeper, evt_log):
        # filekeeper redis
        self.fk = redis.StrictRedis(
            host=filekeeper.get('host'),
            port=filekeeper.get('port'),
            db=0,
        )
        # gatekeeper redis
        self.gk = redis.StrictRedis(
            host=gatekeeper.get('host'),
            port=gatekeeper.get('port'),
            db=0,
        )
        self.gk_expire = gatekeeper.get('expire')
        # jobkeeper redis
        self.jk = redis.StrictRedis(
            host=jobkeeper.get('host'),
            port=jobkeeper.get('port'),
            db=0,
        )

        self.case = evt_log.get('case')
        self.logger = logging.getLogger('strelka')
        self.logger.propagate = False
        self.logger.addHandler(
            logging.handlers.WatchedFileHandler(
                evt_log.get('path'),
                delay=True,
            )
        )

    def StreamData(self, request_iterator, context):
        timestamp = datetime.datetime.utcnow().isoformat()
        root = uuid.uuid4().hex
        task = {
            'root': root,
            'expire': math.ceil(context.time_remaining()),
            'flavors': [],
        }

        cli_req = {}
        cli_meta = {}
        cli_case = ''
        m = hashlib.sha256()
        for request in request_iterator:
            m.update(request.data)
            p = self.fk.pipeline()
            p.rpush(root, request.data)
            p.expire(root, task['expire'])
            p.execute()

            if not cli_req and request.request:
                cli_req['uid'] = request.request.uid or root
                cli_req['client'] = request.request.client
                cli_req['source'] = request.request.source
            if 'filename' not in cli_req and request.filename:
                cli_req['filename'] = request.filename
            if not task['flavors'] and request.metadata.flavors:
                task['flavors'] = [f for f in request.metadata.flavors]
            if not cli_meta and request.metadata.metadata:
                cli_meta = {
                    key: value
                    for (key, value) in request.metadata.metadata.items()
                }
            if not cli_case and request.retrieve.case:
                cli_case = request.retrieve.case

        scan_res = strelka_pb2.ScanResult(uid=cli_req['uid'])
        base_evt = {
            'time': timestamp,
            'request': {**cli_req, 'metadata': cli_meta},
        }

        sha256 = m.hexdigest()
        check = self.gk.exists(sha256)
        if check != 0:
            results = self.gk.lrange(sha256, 0, -1)
            for r in results:
                evt = {
                    **base_evt,
                    **json.loads(r),
                }

                if cli_case:
                    cli_evt = remap_evt(evt, cli_case)
                    scan_res.events.append(json.dumps(cli_evt))
                srv_evt = remap_evt(evt, self.case)
                self.logger.info(json.dumps(srv_evt))
            logging.debug('gk returned result!')
            return scan_res

        p = self.jk.pipeline()
        p.setex(f'{root}:alive', task['expire'], '1')
        p.rpush('queue', json.dumps(task))
        p.execute()

        while context.is_active():
            status = self.jk.get(f'{root}:complete')
            if status is None:
                time.sleep(0.1)
                continue

            p = self.gk.pipeline()
            results = self.jk.lrange(f'{root}:results', 0, -1)
            for r in results:
                p.rpush(sha256, r)
                evt = {
                    **base_evt,
                    **json.loads(r),
                }

                if cli_case:
                    cli_evt = remap_evt(evt, cli_case)
                    scan_res.events.append(json.dumps(cli_evt))
                srv_evt = remap_evt(evt, self.case)
                self.logger.info(json.dumps(srv_evt))

            p.expire(sha256, self.gk_expire)
            p.execute()
            break

        self.jk.delete(f'{root}:alive')
        return scan_res

    def SendLocation(self, request, context):
        timestamp = datetime.datetime.utcnow().isoformat()
        root = uuid.uuid4().hex
        task = {
            'root': root,
            'expire': math.ceil(context.time_remaining()),
            'flavors': [],
        }

        cli_location = {
            key: value
            for (key, value) in request.location.items()
        }
        cli_req = {
            'uid': request.request.uid or root,
            'client': request.request.client,
            'source': request.request.source,
        }
        cli_meta = {
            key: value
            for (key, value) in request.metadata.metadata.items()
        }
        cli_case = request.retrieve.case

        scan_res = strelka_pb2.ScanResult(uid=cli_req['uid'])
        base_evt = {
            'time': timestamp,
            'request': {**cli_req, 'metadata': cli_meta},
        }

        # only http currently supported
        if cli_location['type'] == 'http':
            # this needs options read from env
            response = requests.get(cli_location['object'],
                                    allow_redirects=True,
                                    stream=True,
                                    verify=False)
            if response.status_code == 200:
                for r in response.iter_content(chunk_size=16384):
                    p = self.fk.pipeline()
                    p.rpush(root, r)
                    p.expire(root, task['expire'])
                    p.execute()
            else:
                return scan_res

        p = self.jk.pipeline()
        p.setex(f'{root}:alive', task['expire'], '1')
        p.rpush('queue', json.dumps(task))
        p.execute()

        while context.is_active():
            status = self.jk.get(f'{root}:complete')
            if status is None:
                time.sleep(0.1)
                continue

            results = self.jk.lrange(f'{root}:results', 0, -1)
            for r in results:
                evt = {
                    **base_evt,
                    **json.loads(r),
                }

                if cli_case:
                    cli_evt = remap_evt(evt, cli_case)
                    scan_res.events.append(json.dumps(cli_evt))
                srv_evt = remap_evt(evt, self.case)
                self.logger.info(json.dumps(srv_evt))

            break

        self.jk.delete(f'{root}:alive')
        return scan_res


run = 1


def main():
    def handler(sig, frame):
        global run
        run = 0

    signal.signal(signal.SIGTERM, handler)
    signal.signal(signal.SIGINT, handler)

    parser = argparse.ArgumentParser(prog='strelka-frontend',
                                     description='runs Strelka gRPC frontend',
                                     usage='%(prog)s [options]')
    parser.add_argument('-c', '--frontend-config',
                        action='store',
                        dest='frontend_cfg_path',
                        help='path to frontend configuration file')
    args = parser.parse_args()

    frontend_cfg_path = ''
    if args.frontend_cfg_path:
        if not os.path.exists(args.frontend_cfg_path):
            sys.exit(f'sysexit: frontend configuration {args.frontend_cfg_path} does not exist')
        frontend_cfg_path = args.frontend_cfg_path
    elif os.path.exists('/usr/local/etc/strelka/frontend.yaml'):
        frontend_cfg_path = '/usr/local/etc/strelka/frontend.yaml'
    else:
        sys.exit('sysexit: no frontend configuration found')

    with open(frontend_cfg_path) as f:
        frontend_cfg = yaml.safe_load(f.read())

    log_cfg_path = frontend_cfg.get('logging_cfg')
    with open(log_cfg_path) as f:
        logging.config.dictConfig(yaml.safe_load(f.read()))
    logging.info(f'using frontend configuration {frontend_cfg_path}')

    grpc_cfg = frontend_cfg.get('grpc')
    evt_log = frontend_cfg.get('evt_log')
    fk_cfg = frontend_cfg.get('filekeeper')
    gk_cfg = frontend_cfg.get('gatekeeper')
    jk_cfg = frontend_cfg.get('jobkeeper')

    try:
        if redis.StrictRedis(host=fk_cfg.get('host'), port=fk_cfg.get('port'), db=0).ping():
            logging.debug('verified filekeeper is up')
        if redis.StrictRedis(host=gk_cfg.get('host'), port=gk_cfg.get('port'), db=0).ping():
            logging.debug('verified gatekeeper is up')
        if redis.StrictRedis(host=jk_cfg.get('host'), port=jk_cfg.get('port'), db=0).ping():
            logging.debug('verified jobkeeper is up')
    except Exception:
        logging.exception('redis server(s) unavailable')
        sys.exit()

    executor = futures.ThreadPoolExecutor(max_workers=grpc_cfg.get('threads'))
    server = grpc.server(
        executor,
        maximum_concurrent_rpcs=grpc_cfg.get('max_rpcs'),
    )
    strelka_pb2_grpc.add_StrelkaServicer_to_server(
        StrelkaServicer(fk_cfg, gk_cfg, jk_cfg, evt_log),
        server,
    )
    server.add_insecure_port(grpc_cfg.get('address'))
    server.start()
    while run:
        time.sleep(1)

    logging.info('shutdown process initiated')
    stop = server.stop(grpc_cfg.get('shutdown'))
    logging.debug('stopping gRPC server')
    stop.wait()
    logging.info('finished')


if __name__ == '__main__':
    main()
